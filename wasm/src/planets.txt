use js_sys::Object;
use ndarray::Array;
use wasm_bindgen::prelude::*;
use std::collections::HashMap;

const NUM_POINTS: usize = 1000;

struct Planet {
    name: String,
    distance_au: f64,
    eccentricity: f64,
    inclination_deg: f64,
}

fn calculate_radius(eccentricity: f64, a: f64) -> Vec<f64> {
    let theta = Array::linspace(0.0, 2.0 * std::f64::consts::PI, NUM_POINTS);
    let cos_theta = theta.mapv(f64::cos);
    let r = a * (1.0 - eccentricity.powi(2)) / (1.0 - eccentricity * &cos_theta);
    r.to_vec()
}

fn generate_radius_lookup(planets_data: &[Planet], planets_names: &js_sys::Array) -> HashMap<String, Vec<f64>> {
    let mut radius_values: HashMap<String, Vec<f64>> = HashMap::new();

    for planet in planets_data.iter() {
        for i in 0..planets_names.length() {
            let js_value = planets_names.get(i);
            if let Some(js_string) = js_value.as_string() {
                if js_string == planet.name {
                    let r = calculate_radius(planet.eccentricity, planet.distance_au);
                    radius_values.insert(planet.name.clone(), r);
                    break;
                }
            }
        }
    }

    radius_values
}

#[wasm_bindgen(js_name = getPlanetsRadiusLookupTable)]
pub fn get_planets_radius_lookup_table(planets_names: js_sys::Array) -> Object {
    let planets_data: [Planet; 2] = [
        Planet {
            name: "Earth".to_string(),
            distance_au: 1.0,
            eccentricity: 0.02,
            inclination_deg: 0.0,
        },
        Planet {
            name: "Mars".to_string(),
            distance_au: 1.523,
            eccentricity: 0.09,
            inclination_deg: 1.85,
        },
    ];
    let js_object = js_sys::Object::new();
    for planet in planets_data.iter() {
        for i in 0..planets_names.length() {
            let js_value = planets_names.get(i);
            if let Some(js_string) = js_value.as_string() {
                if js_string == planet.name {
                    let js_array = js_sys::Array::new();
                    let radius_data = calculate_radius(planet.eccentricity, planet.distance_au);
        for value in radius_data.iter() {
            js_array.push(&JsValue::from_f64(*value));
        }
        js_sys::Reflect::set(&js_object, &JsValue::from_str(&planet.name), &js_array).unwrap();
                    break;
                }
            }
        }
    }
    js_object
}

    // let radius_values = generate_radius_lookup(&planets_data, &planets_names);

    // let js_object = js_sys::Object::new();
    // for (planet_name, radius_data) in radius_values.iter() {
    //     let js_array = js_sys::Array::new();
    //     for value in radius_data.iter() {
    //         js_array.push(&JsValue::from_f64(*value));
    //     }
    //     js_sys::Reflect::set(&js_object, &JsValue::from_str(planet_name), &js_array).unwrap();
    // }